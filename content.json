{"meta":{"title":"Code is not cold.","subtitle":null,"description":null,"author":"George Kuo","url":"http://georgekuo.github.io"},"pages":[],"posts":[{"title":"生命週期(Life Cycle)","slug":"react-lifecycle","date":"2018-09-20T09:22:00.000Z","updated":"2018-11-07T04:10:58.589Z","comments":true,"path":"2018/9/20/react-lifecycle/","link":"","permalink":"http://georgekuo.github.io/2018/9/20/react-lifecycle/","excerpt":"","text":"每一個 React 元件都有自己的生命周期，React 為元件提供了許多生命週期相對應的方法(事件)，讓我們可以在元件發生前、發生後，甚至是被消滅的情況下，可以藉由這些方法來設計一些行為。 元件的生命週期有三個主要的部分：Mountint, Updating 以及 Unmounting，以下以目前最新的 React 16.4 生命週期簡介之。 Mounting：掛載階段，元件正準備要被寫入 DOM，按以下順序調用這些方法： constructor() static getDerivedStateFromProps() render() componentDidMount()(註: React 16 已不建議使用 UNSAFE_componentWillMount()) Updating：更新階段，元件偵測到狀態的改變準備重新渲染，按以下順序調用這些方法： static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate()(註: React 16 已不建議使用 UNSAFE_componentWillUpdate()與UNSAFE_componentWillReceiveProps()) Unmounting：卸載階段，元件正要被從 DOM 中移除，，按以下順序調用這些方法： componentWillUnmount() Mounting 掛載階段 constructor(): 這是 ES6 對類別的默認方法，該方法是類別中必須要有的，如果沒有定義 counstructor，則會默認添加空的constructor( )方法。在實現 React.Component 構造函數時，需要先在添加其他內容前，調用 super(props)，用來將父元件傳來的 props 綁定到這個類別中。 static getDerivedStateFromProps(): getDerivedStateFromProps 在組件實例化後，和接受新的 props 與 state 後被調用。每次接收新的 props 之後都會返回一個 object 作為新的 state，或者返回 null 表示新的 props 不需要任何 state 的更新。 render(): render()方法是必需的。當它被調用時，他將計算 this.props 和 this.state，並返回以下其中一種類型: React 物件/陣列和fragments/Portals/字串和數字/布林值或 null。 componentDidMount(): 當元件被寫入 DOM 之後觸發，當初始化需要操作 DOM 元素就可以用這個方法，在此階段通常會用於 DOM 操作、ajax、side effect 以及事件監聽。不能在此做 setState 的操作，以免造成重複渲染。Updating 更新階段 shouldComponentUpdate(): 這個函式會回傳一個布林值(默認會回傳 true)，當元件接收到新的 props 或 state 時被觸發。你可以在這個方法裡面去比較 this.props，this.state，nextProps，nextState 來決定是否需要更新，回傳 false 則會跳過此次觸發不更新，如果你什麼都不回傳預設會當做 false。 getSnapshotBeforeUpdate(): 觸發時間是 update 發生時，在 render 之後，以及在元件 DOM 渲染之前，返回的值做為 componentDidUpdate 的第三個參數，這方法可以取代 componentWillUpdate。 componentDidUpdate(): 此函數通常用於進行非同步請求以及事件綁定，在元件完成更新後立即執行。必須注意，componentDidUpdate 在初始化時，以及 shouldComponentUpdate() 返回 false 時，不會被執行。不能在此做 setState 的操作，以免造成重複渲染。Unmounting 卸載階段 componentWillUnmount(): 主要用來執行一些必要的清理任務。例如清除 setTimeout 等函數，或者任意的在 componentDidMount 創建的 DOM 元素。參考連結:React 16 - The Complete Guide元件運作與生命週期组件生命周期React 元件生命週期[筆記]React.Componentcss88 中譯: React.Component","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://georgekuo.github.io/tags/react/"},{"name":"lifecycle","slug":"lifecycle","permalink":"http://georgekuo.github.io/tags/lifecycle/"}]},{"title":"狀態 (state)","slug":"react-state","date":"2018-09-13T13:44:00.000Z","updated":"2018-11-07T04:10:57.850Z","comments":true,"path":"2018/9/13/react-state/","link":"","permalink":"http://georgekuo.github.io/2018/9/13/react-state/","excerpt":"","text":"狀態(state)和屬性(props)類似，都是一個元件所需要的一些數據資料集合，但是 State 是私有的，它不能被自身元件以外的任何元件使用， React 把元件看成是一個狀態機，如果元件沒有狀態，那就只需要寫成函式元件並透過 props 傳遞資料，不需要寫成類別元件，但如果需要與使用者進行互動，就必須使用 State，先由 State 初始化元件本身的資料，再由 setState 方法改變元件的資料，進而渲染改變過後的 DOM 元素。 無狀態需要改變: 函式元件當我們並不須跟使用者互動時，我們的元件只需寫成函式元件就好，也就是說，我們只要寫一個 function component，並用 props 傳遞資料給子元件即可。 1234567891011121314151617function TheLast (props) &#123; return( &lt;div&gt; &lt;h2&gt;I am &#123;props.name&#125; and &#123;props.age&#125; years old.&lt;/h2&gt; &lt;h2&gt;My partner is &#123;props.partner&#125;&lt;/h2&gt; &lt;/div&gt; )&#125;const element = &lt;TheLast name=\"Joel\" age=\"55\" partner=\"Ellie\" /&gt;ReactDOM.render( element, document.getElementById(\"root\"))// I am Joel and 55 years old.// My partner is Ellie 但如果我們想要改變元件的資料，我們就必須寫成類別元件。 有狀態需要改變: 類別元件上面的函式元件如果我們想要改變姓名(Joel)與年齡(55)，我們就要改成類別元件。 首先，function TheLast(props) 改成 class TheLast extends React.Componentfunction component 的 state 要寫在 constructor() 裡。state 是個物件，所以狀態的資料必須以物件形式撰寫，例如 this.state = {…}看到了嗎？我們用了 this.state，super()是用來初始化 this 的，可以綁定事件到 this 上。所以我們的 constructor 會變成以下這樣： 12345678constructor()&#123; super() this.state = &#123; name: 'Joel', age: 55, partner: 'Ellie' &#125;&#125; 接下來就單純多了，在 function component 裡面我們用return顯示 JSX 結構，但是 class component 則用render方法把 return包住，所以整個重新改寫的元件會長這樣： 123456789101112131415161718class TheLast extends React.Component &#123; constructor()&#123; super() this.state = &#123; name: 'Joel', age: 55, partner: 'Ellie' &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;I am &#123;this.state.name&#125; and &#123;this.state.age&#125; years old.&lt;/h2&gt; &lt;h2&gt;My partner is &#123;this.state.partner&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125; setState接著我們進入本篇的重點，setState。setState 的工作除了更新 this.state 之外，還要負責觸發重新渲染(re-render)。 讓我們寫一個能改變 state 的 function 並命名為 switchNameHandler1，裡面用this.setState設置新的 state value，這裡有兩個重點： 要改變狀態一定要用 this.setState 而非 this.State，後者只用在狀態的初始化。this.setState 是函數，可接受一個 function 或 object 作為參數，在此例我們用 object 做為參數。 12345// setState 語法setState( function | object nextState, [function callback]) 在這兒我們想要用 setState 把 Joel 跟 55 換掉，變成 George 跟 20，所以我們把 this.state 想改變的值寫在 this.setState 的 object 裡，於是 switchNameHandler1 就可寫成以下程式碼： 123switchNameHandler1()&#123; this.setState(&#123;name: 'George', age: 20&#125;)&#125; 然後在 JSX 裡面插入一個 button，並且安置一個 onClick 事件並用花括號包住 setState 的 function name。 1&lt;button onClick = &#123;this.switchNameHandler1&#125;&gt;Change state&lt;/button&gt; 此時的程式碼會長這樣子： 1234567891011121314151617181920212223242526class TheLast extends React.Component &#123; constructor()&#123; super() this.state = &#123; name: 'Joel', age: 55, partner: 'Ellie' &#125; &#125; switchNameHandler1()&#123; this.setState(&#123;name: 'George', age: 20&#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;I am &#123;this.state.name&#125; and &#123;this.state.age&#125; years old.&lt;/h2&gt; &lt;h2&gt;My partner is &#123;this.state.partner&#125;&lt;/h2&gt; &lt;button onClick = &#123;this.switchNameHandler1&#125;&gt;Change state&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;TheLast /&gt;, document.getElementById('root')) 但你這時會發現按鈕並沒有作用，這是因為我們沒有把 this 綁定在 switchNameHandler1 上，所以必須要在 constructor 裡多加一行: 1this.switchNameHandler1 = this.switchNameHandler1.bind(this) 這時的 button 就有 setState 的功能了。但是我覺得這樣多寫一行很髒，所以我會用 arrow function 綁定 this 的特性，把 switchNameHandler1 用 arrow function 改寫: 123switchNameHandler1 = () =&gt; &#123; this.setState(&#123;name: 'George', age: 20&#125;)&#125; 完整程式碼如下: 123456789101112131415161718192021222324252627class TheLast extends React.Component &#123; constructor()&#123; super() this.state = &#123; name: 'Joel', age: 55, partner: 'Ellie' &#125; // this.switchNameHandler1 = this.switchNameHandler1.bind(this) &#125; switchNameHandler1 = () =&gt; &#123; this.setState(&#123;name: 'George', age: 20&#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;I am &#123;this.state.name&#125; and &#123;this.state.age&#125; years old.&lt;/h2&gt; &lt;h2&gt;My partner is &#123;this.state.partner&#125;&lt;/h2&gt; &lt;button onClick = &#123;this.switchNameHandler1&#125;&gt;Change state&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;TheLast /&gt;, document.getElementById('root')) setState 的其他特性 this.state 不會在 this.setState 調用之後立刻更新 連續調用多次 this.setState，都只會觸發一次生命週期的更新 參考連結:React 16 - The Complete Guide深入理解React 组件状态（State）React 回憶錄（四）React 中的狀態管理React.Component状态(State) 和 生命周期React JS State and PropssetState：这个API设计到底怎么样","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://georgekuo.github.io/tags/react/"},{"name":"state","slug":"state","permalink":"http://georgekuo.github.io/tags/state/"},{"name":"setState","slug":"setState","permalink":"http://georgekuo.github.io/tags/setState/"}]},{"title":"元件 (Component) 與屬性 (Props)","slug":"react-props","date":"2018-09-12T00:03:00.000Z","updated":"2018-11-07T04:10:56.535Z","comments":true,"path":"2018/9/12/react-props/","link":"","permalink":"http://georgekuo.github.io/2018/9/12/react-props/","excerpt":"","text":"元件 (Component) 讓你可以將用戶界面分成獨立的，可重複使用的小元件，並且可以對每個部件進行單獨的設計，是 React 最基本也最重要的觀念之一。 最簡單的定義元件的方法是寫一個 JavaScript 函數。 123function Person(props) &#123; return &lt;h1&gt;My name is &#123;props.name&#125;&lt;/h1&gt;;&#125; Person 函數是一個有效的 React 元件，因為它接收一個 props 參數, 並返回一個 React 元素。這稱為”函數式(Functional)“元件， 因為從字面上看來它就是一個 JavaScript 函數。你也可以用 ES6 的 class 定義元件。 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 以上的 與 都是合法的 React Component，相信你也注意到他們命名的第一個字母都必須要大寫。 元件互嵌元件的另一個好處是，他們可以互相嵌入對方的程式碼，例如以上兩個 與 可以將它們組合在一起。 12345678910111213141516171819202122function Person(props) &#123; return &lt;h1&gt;My name is &#123;props.name&#125;&lt;/h1&gt;;&#125;class Welcome extends React.Component &#123; render() &#123; return( &lt;div&gt; &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &lt;Person name='Kobe' /&gt; &lt;/div&gt; ) &#125;&#125;const element = &lt;Welcome name=\"Shaq\" /&gt;ReactDOM.render( element, document.getElementById('root'))//印出Hello, ShaqMy name is Kobe 這裡要注意的是必須要用一個空的 div 把 &#60;h1&#62;Hello, {this.props.name}&#60;/h1&#62; 與 包起來，否則會出錯(註)，這是因為 JSX 最終會轉成 JavaScript，且每一個 JSX 節點都對應到一個 JavaScript 函數，所以在 Component 的 render 方法中只能回傳一個根節點 (Root Nodes)。 (註): 在最新的 React 16 版本裡，可使用 &#60;React.Fragment&#62;&#60;/React.Fragment&#62; 取代 &#60;div&#62;&#60;/div&#62;，如此一來，將不會 render 無意義的 &#60;div&#62;&#60;/div&#62; Props如果你用函數定義一個 React 元件，你可透過 props 讓父元件傳值給子元件，props 是不可變的，我們不應該去改變子元件的 props 值，子元件的 props 值只取決於父元件傳了什麼值給它。 12345678910function User(props)&#123; return &lt;h1&gt;Hi, &#123;props.name&#125;&lt;/h1&gt;&#125;const me = &lt;User name='George' /&gt;ReactDOM.render( me, document.getElementById('root'))//Hi, George 以上的程式碼將會印出 Hi, George。當我們用創建一個 User Component，並且在裡面設立了一個 props.name 的接口，然後我定義了常數 me 為一個 User 元件，並在裡面設置了一個 name 值為 George，當我在 render 的時候，就會以 George 去輸出為 &#60;User /&#62; 的 props value。 參考連結:React 16 - The Complete GuideReact Props组件(Components) 和 属性(Props)","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://georgekuo.github.io/tags/react/"},{"name":"component","slug":"component","permalink":"http://georgekuo.github.io/tags/component/"},{"name":"props","slug":"props","permalink":"http://georgekuo.github.io/tags/props/"}]},{"title":"JSX 簡介","slug":"react-jsx","date":"2018-09-10T16:03:00.000Z","updated":"2018-11-07T03:20:52.211Z","comments":true,"path":"2018/9/11/react-jsx/","link":"","permalink":"http://georgekuo.github.io/2018/9/11/react-jsx/","excerpt":"","text":"React 以 Component 為基礎，為了增進效率，我們常會在撰寫 React Component 時使用 JSX 的方式來提升程式撰寫效率。 JSX 是一種可以讓 HTML 標記直接寫在 JavaScript 程式碼中的擴充語法，為了它是 React 自創的 React.createElement 的一種簡寫法，需要經過 babel 工具編譯才能執行，可視為是創建元素的語法糖，在使用 React 的时候，JSX 並不是强制要求的,你可以選擇性的使用。 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt; 上面的 &#60;h1&#62;Hello, world!&#60;/h1&#62; 乍看之下跟 HTML 並無二異，但這卻是不折不扣的 JSX，因為它跟一般人較為熟悉的 HTML 語法相似也較易維護，這也是為何我們會選擇用 JSX 而不用 React.createElement 的原因。 以下的例子是完全相同的： 12345678910111213//JSXconst element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);// React.createElementconst element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); Babel 會幫我們把上面 JSX 的程式碼編譯成下面 React.createElement 的程式碼。事實上，React 並沒有強制我們一定要使用 JSX，如果你完全不用 JSX 也是可以的，只是因為 JSX 程式碼閱讀起來較為友善，所以 JSX 成為了撰寫 React 的主流，如果你想更詳細了解 JSX 如何轉譯成 React.createElement，可用 Babel 提供的轉譯器做測試。 雖然 JSX 跟 HTML 語法類似，但請記住一件事，JSX 骨子裡還是 JavaScript，以下是 JSX 的一些小眉角。 JSX 的花括號花括號可把任意的 JavaScript 表達式嵌入到 JSX 中。例如，2 + 2， user.avatarUrl 和 formatName(user)，這些都是可用的表達式。 在下面的例子中，我們調用 JavaScript 函數 formatName(user) 的結果嵌入到 &#60;h1&#62; 元素中。 12345678910111213141516171819function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); 又或者用花括號嵌入一個 JavaScript 表達式作為屬性值 1const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;; 多行 JSX 需以小括號包覆JSX 分割成多行時，必須使用小括號將 JSX 包裹起來，避免分號自動插入。 正確來說是讓JS認為這行語句尚未結束，而不會作ASI的來結束語句。如果return後面沒有加上圓括號的開頭符號(()，ASI會起作用然後會幫你自動加上分號(;)，這將會造成語法錯誤或是不預期的結果。https://eyesofkids.gitbooks.io/react-basic-zh-tw/content/day06_es6_arrow_func/ 12345678910111213141516171819202122//Wrongfunction Avengers()&#123; return &lt;ul&gt; &lt;li&gt;IronMan&lt;/li&gt; &lt;li&gt;Hulk&lt;/li&gt; &lt;li&gt;Thor&lt;/li&gt; &lt;li&gt;Caption American&lt;/li&gt; &lt;/ul&gt;&#125;//Rightfunction Avengers()&#123; return ( &lt;ul&gt; &lt;li&gt;IronMan&lt;/li&gt; &lt;li&gt;Hulk&lt;/li&gt; &lt;li&gt;Thor&lt;/li&gt; &lt;li&gt;Caption American&lt;/li&gt; &lt;/ul&gt; )&#125; JSX 的駝峰式寫法React DOM 使用 camelCase 屬性命名約定而不是 HTML 屬性名稱，所以 tabindex 在 JSX中要寫作 tabIndex，class 是 JavaScript 中的保留字，所以 class 屬性用 className 替代。 1234const name = 'Clementine';ReactDOM.render( &lt;h1 className=\"hello\"&gt;My name is &#123;name&#125;!&lt;/h1&gt;, document.getElementById('root')); JSX 註解語法JSX 註解以 {/ 與 /} 包覆欲註解的語句 12345678function UserInfo(props) &#123; return ( &lt;div className=\"UserInfo\"&gt; &#123;/* &lt;Avatar user=&#123;props.user&#125; /&gt; */&#125; &lt;div className=\"UserInfo-name\"&gt;&#123;props.user.name&#125;&lt;/div&gt; &lt;/div&gt; );&#125; 參考連結:React 16 - The Complete GuideReact - DOM界的彼方JSX 介绍深入 JSX一看就懂的 JSX 簡明入門教學指南","categories":[],"tags":[{"name":"jsx","slug":"jsx","permalink":"http://georgekuo.github.io/tags/jsx/"},{"name":"react","slug":"react","permalink":"http://georgekuo.github.io/tags/react/"}]},{"title":"Promise","slug":"promise","date":"2018-08-22T07:13:17.000Z","updated":"2018-09-02T09:09:26.182Z","comments":true,"path":"2018/8/22/promise/","link":"","permalink":"http://georgekuo.github.io/2018/8/22/promise/","excerpt":"","text":"JavaScript 有些程式是非同步的(例如 ajax, setTimeout, setInterval)，為了確保這些非同步程式能照我們想要的順序執行，我們使用了回呼函式 (以下稱 callback function) 來達成我們的需求，但 callback function 有個問題是只要程序一多，程式碼會變得非常難以閱讀，於是 ES6 提出了一個解決方案：Promise。 甚麼是 Promise? 首先要知道，Promise 是一個物件(object)，它代表一個即將完成、或失敗的非同步操作，以及它所產生的值。一個 Promise 物件透過 new 及其建構式建立。這個建構式接收一個叫作”執行器函式（executor function）”的引數。此函式裡面有兩個 callback function 作為引數，分別是 resolve 與 reject。 1new Promise( /* executor */ function(resolve, reject) &#123; ... &#125; ); resolve 與 reject 函數的作用任何一個 Promise 物件在剛被建立時，一定都是處於 pending 狀態，只有執行完裡面的非同步程式後，才能確認該 Promise 是成功或失敗。 如果該 Promise 的非同步程式成功完成時，將會執行第一個函式 resolve 之結果值，相對的，若非同步程式失敗時，Promise 將會執行第二個函式 reject 之結果值。簡單的說，即是把這兩個 callback function 當作該 Promise 成功或失敗的接口。 成功便調用第一個回呼函數 resolve，將參數傳遞出去。失敗便調用第二個回呼函數 reject，將參數傳遞出去。 12345const myPromise = new Promise(function(resolve, reject)&#123; // do something resolve(value) // 成功便執行 resolve 的 value 值 reject(reason) // 失敗便執行 reject 的 reason 值&#125;) resolve 與 reject 可任意命名Executor 裡面的 callback function（resolve 與 reject）可用其他名稱代替。 12345const myPromise = new Promise(function(successed, failed)&#123; // do something successed(value) // 成功便執行 successed 的 value 值 failed(reason) // 失敗便執行 failed 的 reason 值&#125;) 第二個 reject 函式不一定要放resolve 或 reject 函式不必兩個都放，如果你確定你的 Promise 裡面的程式一定會執行成功，可以只放第一個 callback function，也就是 resolve。如果你的 Promise 可能有失敗結果，就不能偷懶，一定要放兩個 callback function，第一個 callback function 是成功時執行，第二個 callback function 是失敗時執行。 1234const myPromise = new Promise(function(reject)&#123; // do something reject(value) // 成功便執行 reject 的 value 值&#125;) 上面有個小小的陷阱，在 executor 裡面我放了一個叫 reject 的 callback function，雖然它叫 reject，但它其實是成功時才會執行，因為這裡綜合了以上所提到的兩個特性： resolve 與 reject 可任意命名 第二個 reject 函式不一定要放 因為 executor 裡面只有一個 callback functoin，所以它其實代表的是 Promise 成功時才會執行的接口，也就是一般所認知的 resolve 函式。 then()then()方法回傳一個 Promise 物件。它接收兩個引數： Promise 在成功及失敗情況時的 callback function。 then()第一個 callback function 是 Promise 對象的狀態變為 resolved 時調用，第二個 callback function 是 Promise 對象的狀態變為 rejected 時調用，其中第二個 callback function 是可選的，不一定要提供。這兩個函數都接受 Promise 對象傳出的值作為參數。 1234567891011const myPromise = new Promise(function(resolve, reject)&#123; // do something resolve(value) reject(reason) &#125;)myPromise.then(function(value)&#123; // myPromise 狀態為成功時，執行此處程式碼&#125;, function(reason)&#123; // myPromise 狀態為失敗時，執行此處程式碼&#125;) then() 串連還記得我們使用 Promise 的初衷嗎？ 為了讓非同步程式以同步程式操作的流程進行，我們使用 then 方法，依序呼叫兩個以上的非同步函數，而每個 then 方法回傳一個 Promise 以進行方法串接（method chaining），我們稱之為建立 Promise 鏈。 12345myPromise.then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;) catch()catch 與 then 用法相反，它接收 Promise 失敗時的 reject 函式，一般放在 Promise 鏈的最後。1234567891011const myPromise = new Promise(function(resolve, reject)&#123; // do something resolve(value) reject(reason) &#125;)myPromise.then(function(value)&#123; // myPromise 狀態為成功時，執行此處程式碼&#125;.catch(function()&#123; // myPromise 狀態為失敗時，執行此處程式碼&#125;)) 用 catch 定義 reject，別用 then 的第二個 callback function一般來說，盡量不要在 then 方法裡面定義 Reject 狀態的 callback function（即 then 的第二個參數），建議使用 catch 方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 實作接下來讓我們來實作一個簡單的 promise 範例。 1234567891011function logWord(word)&#123; setTimeout(function()&#123; console.log(word) &#125;, Math.floor(Math.random() * 1000))&#125;function allWord()&#123; logWord('a') logWord('b') logWord('c')&#125;allWord(); function logWord 是一個 setTimeout 程式，會 不定時 console 出我們自定的參數，當我們用一個函式 allWord() 把數個 logWord() 包起來，執行時會發現裡面的 logWord 是隨機觸發的，原因是因為Math.floor(Math.random() * 1000)。 但你想要 allWord() 裡面的 logWord() 是依序執行出 a b c，而不是隨機 b c a 或 c a b 時，我們會怎麼做？以前的做法是使用 callback 函式。 123456789101112131415function logWord(word, cb)&#123; //插入 callback setTimeout(function()&#123; console.log(word) cb(); //在主程式最後一行執行 &#125;, Math.floor(Math.random() * 1000))&#125;function allWord()&#123; logWord('a', function()&#123; //放入第1個 callback logWord('b', function()&#123; //放入第2個 callback logWord('c', function()&#123;&#125;) //第3個 callback 裡面是空的，因為已沒有其他需要做的事 &#125;) &#125;)&#125;allWord(); 在 logWord() 插入一個 callback 參數(這裡取名為 cb) ，然後在 setTimeout 主程式的最後一行執行它。 接著執行以下動作: 在 allWord() 裡，將第一個執行的 logWord(‘a’) 插入 callback 當作第二個參數 把 logWord(‘b’) 放在 logWord(‘a’)的 callback，確保會在 console 出 a 才會執行 logWord(‘b’) 把 logWord(‘c’) 放在 logWord(‘b’)的 callback，確保會在 console 出 a 才會執行 logWord(‘c’) logWord(‘c’) callback fuction 為空值，因為此時沒其他事要做了 執行 allWord()，印出 a b c 這時你的程式就會依序印出 a b c 了。 但看看上面的程式碼，我們光只是寫三層 callback 就很累了，更別說之後萬一需要寫更多層的時候了，這時就會陷入萬劫不復的 callback hell (回呼地獄) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function callback(hell)&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hell('no', function()&#123; hollyshit() &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;) &#125;)&#125; 我們用 Promise 來改寫一下上面的程式。 首先在原本的 logWord 返回一個新建的 Promise，語法為本文最一開始的 new Promise( function(resolve, reject) { … } ) 然後把 setTimeout 主程式放入 Promise 裡。為了讓我們的 logWord 可以串連，我們在 setTimeout 主程式最後一行放入 resolve()，讓這個 Promise 物件成功執行時，馬上拋出 resolve。 12345678function logWord(word)&#123; return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; console.log(word) resolve() &#125;, Math.floor(Math.random() * 1000)) &#125;)&#125; 接著我們在 allWord() 裡，用 then 把成功執行的 logWord() 串連起來 12345678910function allWord()&#123; logWord('a') .then(function()&#123; return logWord('b') &#125;) .then(function()&#123; return logWord('c') &#125;)&#125;allWord(); 為了簡潔美觀，我把它改成箭頭函式的寫法。 123456function allWord()&#123; logWord('a') .then(() =&gt; logWord('b')) .then(() =&gt; logWord('c'))&#125;allWord(); 最後的成果，這樣就可依序印出 a b c 1234567891011121314function logWord(word)&#123; return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; console.log(word) resolve() &#125;, Math.floor(Math.random() * 1000)) &#125;)&#125;function allWord()&#123; logWord('a') .then(() =&gt; logWord('b')) .then(() =&gt; logWord('c'))&#125;allWord(); 總結使用 Promise 讓我們可以把非同步操作以同步操作的流程表達出來，它把執行程式和處理結果的程式清晰地分離，同時簡潔的語法，也解決了以前多層 callback function 不好維護的問題。 對於 Promise 我其實還有很多未整理出來的地方，但希望透過這篇文章讓我對我目前所了解的 Promise 做個梳理，有興趣的朋友也可以參考下面所附連結進而更了解 Promise。 參考連結:React 16 - The Complete Guide你所不知道的JS：ES6與未來發展javascript callback functions tutorialPromises - Part 8 of Functional Programming in JavaScript[JavaScript 教學] Callback與Promise (非同步編程基礎)JavaScript Promise 漂亮的串接非同步事件MDN - Promise從Promise開始的JavaScript異步生活Javascript的非同步之旅JavaScript Promise：簡介JAVASCRIPT.INFO - Promise","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"promise","slug":"promise","permalink":"http://georgekuo.github.io/tags/promise/"}]},{"title":"預設參數(Default parameters)","slug":"default-parameters","date":"2018-08-20T05:57:41.000Z","updated":"2018-09-02T09:09:26.178Z","comments":true,"path":"2018/8/20/default-parameters/","link":"","permalink":"http://georgekuo.github.io/2018/8/20/default-parameters/","excerpt":"","text":"函式的傳入參數預設值，在未指定實際的傳入值時，一定是undefined，ES6 的函式預設參數允許沒有值傳入或是傳入值為 undefined 的情況下，參數能以指定的預設值初始化，指定不同的預設值可能在某些情況很管用。 在以前還沒有預設參數的時候，程式會以||防呆，以免參數為 undefined。 1234567891011function foo(x, y)&#123; x = x || 15 y = y || 3 console.log(x + y)&#125;foo() //18foo(3, 4) //7foo(22) //25foo(null, 9) //24foo(undefined, 9) //24 這樣做的好處是，假設一開始的 x 與 y 參數沒有傳入值，利用||可將預設值 15 與 3 帶入，而不致於變成 undefined。但這樣做會有一個陷阱，假設我們傳給參數的值是 falsy 的，你的程式有可能會跟你想得不一樣。 123456function foo(x, y)&#123; x = x || 15 y = y || 3 console.log(x + y)&#125;foo(0, 8) //23 假設你希望的結果是 0 + 8，那你的程式就出包了，因為 0 在||旁被視為 falsy，所以你的 x 被自動帶入 15，變成 15 + 3。為了消除這種陷阱，有些人會用嚴格相等式測試帶入的參數是不是 undefined：123456function foo(x, y)&#123; x = (x !== undefined) ? x : 15 y = (y !== undefined) ? y : 3 console.log(x + y)&#125;foo(0, 8) //8 但現在我們可以直接在參數就把預設值帶入，這樣使得我們的防呆機制變得更簡潔。 123456789function foo(x = 15, y = 3)&#123; console.log(x + y)&#125;foo() //18foo(3, 4) //7foo(22) //25foo(null, 9) //9foo(undefined, 9) //24 參數預設值的規則是，如果函數呼叫時本來就有值，參數預設值就會自動忽略，反之，如果沒有值或是 undefined，參數就會以預設值帶入。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'George') // Hello Georgelog('Hello', '') // Hello George 1234567function multiply(a, b = 1) &#123; return a * b;&#125;multiply(5, 2); // 10multiply(5, 1); // 5multiply(5); 123const link = function (point = 10, url = 'http://google.com') &#123; //...&#125; 參數預設值不能用let或const再次宣告。 1234function foo(x = 5) &#123; let x = 1 // error const x = 2 // error&#125; 使用參數預設值時，函數不能有同名參數。 123456789// 不會報錯function foo(x, x, y) &#123; // ...&#125;// 報錯，因為用了參數預設值function foo(x, x, y = 1) &#123; // ...&#125; 預設參數值的位置預設參數值並沒有限定位置，但在 airbnb 的規範裡表明，有預設值的參數，應該要放在沒有預設值的參數後面，這樣會讓有預設值的參數一目瞭然，比較不容易出錯。123456789// 壞寫法function handleThings(opts = &#123;&#125;, name) &#123; // ...&#125;// 好寫法function handleThings(name, opts = &#123;&#125;) &#123; // ...&#125; 與箭頭函式的搭配箭頭函式也可帶入參數預設值，需要注意的是，假設你的箭頭函式只有一個參數時，加上參數預設值，必須加上圓括號。 1const add = (x = 1) =&gt; x + 2 參考連結:React 16 - The Complete GuideReact - DOM界的彼方(繁中)MDN - 預設參數ECMAScript 6 入门你所不知道的JS：ES6與未來發展","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"default parameters","slug":"default-parameters","permalink":"http://georgekuo.github.io/tags/default-parameters/"}]},{"title":"類別(Classes)","slug":"es6-class","date":"2018-08-20T02:05:32.000Z","updated":"2018-09-02T09:09:26.179Z","comments":true,"path":"2018/8/20/es6-class/","link":"","permalink":"http://georgekuo.github.io/2018/8/20/es6-class/","excerpt":"","text":"在 ES6 以前，想要簡化相同程式碼，必須用 prototype 原型來達到類與類繼承，ES6 引入了類別(Class)作為 JavaScript 現有原型程式(prototype-based)的語法糖，提供了一個更簡潔的語法來建立物件與處理繼承。 類別(Classes)實際上是一種特別的函數，就跟你可以定義函數敘述和函數宣告一樣。透過 Class 建立物件，將兩個或多個物件的相同結構抽取出來變成一個模板，再依照模版複製出其他相似物件，這使我們不必再寫重複的程式碼。 要建立一個新的類別，必須用關鍵字Class，如下所示，我們建立一個名為 Person 的類別，在此類別可為它建立屬性與方法。 1234class Person &#123; //注意 class 為小寫，Person 首字大寫 name: 'George' //建立 name 屬性 call: = () =&gt; &#123;&#125; //建立 call 方法&#125; 現在我們來改寫一下上面的程式碼，我們加入 class 另一個功能constructor，它代表類別的主體內容，一個類別只能有一個 constructor，當類別中含有一個以上的建構子方法時，SyntaxError 將會被拋出。在這裡我們把 name 屬性放進 constructor 裡，然後加上 printMyName 方法。 12345678class Person &#123; constructor()&#123; this.name = 'George' &#125; printMyName()&#123; console.log(this.name) &#125;&#125; 現在我們已經建立了一個名為 Person 的 Class，已經可以用建構式使用它了。 1234567891011class Person &#123; constructor()&#123; this.name = 'George' &#125; printMyName()&#123; console.log(this.name) &#125;&#125;const person = new Person()person.printMyName() //'George' 接著我們來練習 Class 繼承。我們建立一個名為 Human 的類別，然後在原本的 Person 後面用extends關鍵字，extends 是在類別宣告或是類別敘述中建立子類別的方法。接上繼承的父類別名稱 Human，最後在最下方呼叫 person 的 printGender 方法。 1234567891011121314151617181920class Human &#123; constructor()&#123; this.gender = 'Male' &#125; printGender()&#123; console.log(this.gender) &#125;&#125;class Person extends Human &#123; constructor()&#123; this.name = 'George' &#125; printMyName()&#123; console.log(this.name) &#125;&#125;const person = new Person()person.printMyName() person.printGender() // error 這時系統會拋出 error，這是因為當我們繼承父類別時，在子類別中若有 constructor，要使用 this 前，必須先呼叫super()函式。簡而言之，super是用來提供一個類別呼叫其父類別的函數。 123456789101112131415161718192021class Human &#123; constructor()&#123; this.gender = 'Male' &#125; printGender()&#123; console.log(this.gender) &#125;&#125;class Person extends Human &#123; constructor()&#123; super() //加上 super() 呼叫父類別建構子 this.name = 'George' &#125; printMyName()&#123; console.log(this.name) &#125;&#125;const person = new Person()person.printMyName() //'George'person.printGender() //'Male' 用 extends 擴充傳統函式你也可以擴充(extends)傳統的函式基礎”類別”。 12345678910111213141516function Animal (name) &#123; this.name = name; &#125;Animal.prototype.speak = function () &#123; console.log(this.name + ' makes a noise.');&#125;class Dog extends Animal &#123; speak() &#123; console.log(this.name + ' barks.'); &#125;&#125;var d = new Dog('Mitzie');d.speak(); // Mitzie barks. 參考連結:React 16 - The Complete GuideMDN - ClassesECMAScript 6 入门 - Class 的基本语法ECMAScript 6 入门 - Class 的继承深入理解 JavaScript 中的 class你所不知道的JS：ES6與未來發展","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"class","slug":"class","permalink":"http://georgekuo.github.io/tags/class/"},{"name":"constructor","slug":"constructor","permalink":"http://georgekuo.github.io/tags/constructor/"},{"name":"super","slug":"super","permalink":"http://georgekuo.github.io/tags/super/"}]},{"title":"分散 / 其餘(Spread/Rest)","slug":"spread-rest-operators","date":"2018-08-17T06:10:27.000Z","updated":"2018-09-02T09:14:21.052Z","comments":true,"path":"2018/8/17/spread-rest-operators/","link":"","permalink":"http://georgekuo.github.io/2018/8/17/spread-rest-operators/","excerpt":"","text":"ES6 引進一個新的 … 運算子(你沒看錯，就是三個點)，它通常被稱為 spread(分散) 或 rest(其餘) 運算子，取決於被使用的時機與方式。 分散(Spread)分散(spread)用於將 陣列 展開為個別的值。123const numbers = [1, 2, 3]const newNumbers = [...numbers, 4]console.log(newNumbers) //[1, 2, 3, 4] 也可拿來複製物件屬性12345678const person = &#123; name: 'Tony'&#125;const newPerson = &#123; ...person, age: 20&#125;console.log(newPerson) // &#123;name: 'Tony', age 20&#125; 在函數調用時，我們也可以用 spread 123function myFunction(x, y, z) &#123; &#125;var args = [0, 1, 2]myFunction(...args) 在 ES5 時，想要將 array 新增至另一個 array 時，只能用 push, splice, concat 等方法，現在我們可以用 spread 輕鬆的完成這些事。 123var girls = ['Stacy'，'Mary'] var friends = ['Tommy'，...girls，'Wong'，'Gary'] // [\"Tommy\", \"Stacy\", \"Mary\", \"Wong\", \"Gary\"] 其餘(Rest)另一個用法被視為是相反的動作，它不是分散值，而是將一組值 聚集 為一個 陣列。 在以下程式碼中，…z 表示將 其餘 的引數聚集為一個叫做 z 的陣列。因為 x 被指定為 1，y 被指定為 2，剩下的 3, 4, 5 就會被聚集成名為 z 的陣列。1234function foo(x, y, ...z)&#123; console.log(x, y, z)&#125;foo(1, 2, 3, 4, 5) //1 2 [3, 4, 5] 現在我們知道 rest 可以將引數聚集成一個陣列，所以我們也可把它用在需要陣列的方法中，例如 map(), filter()…等。1234const twice = (...args) =&gt; &#123; return args.map((i) =&gt; i*2) //引數1,2,3&#125;console.log(twice(1, 2, 3)) // [2, 4, 6] 總結 分散(spread) 用於 陣列字面 與 函式呼叫12const a = [...arr, b]f(...arr) 其餘(rest)) 用於 函式傳入參數設定 與 解構賦值12function f(...arr)&#123;&#125;const[a, ...b] = [1, 2, 3] 參考連結:React 16 - The Complete GuideMDN - 展开语法ES6篇: Spread Operator &amp; Rest Operator(展開與其餘運算符)ECMAScript 6 入门你所不知道的JS：ES6與未來發展","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"spread","slug":"spread","permalink":"http://georgekuo.github.io/tags/spread/"},{"name":"rest","slug":"rest","permalink":"http://georgekuo.github.io/tags/rest/"}]},{"title":"箭頭函式(Arrow Function)","slug":"arrow-function","date":"2018-08-15T06:24:02.000Z","updated":"2018-09-02T09:09:26.177Z","comments":true,"path":"2018/8/15/arrow-function/","link":"","permalink":"http://georgekuo.github.io/2018/8/15/arrow-function/","excerpt":"","text":"箭頭函式 Arrow Function 是 ES6 非常受人喜愛的功能，同時支援普通函式所具備的功能，包括預設值、解構、rest 參數，它擁有以下幾個特性： 更短的函式寫法(怎麼寫) 綁定 this(怎麼用) 更短的函式寫法先說結論，使用箭頭函式，以下兩種寫法是相等的。123456//normal functionfunction add(x)&#123; return x + 5&#125;//arrow functionconst add = x =&gt; x + 5 Step by Step讓我們先寫一般普通的 Function，帶兩個參數 x 跟 y，然後 return x + y1234//normal functionfunction add(x, y)&#123; return x + y&#125; Arrow Function 把函式本身儲存在一個變數或常數，中間用等號 = 隔開 123const add = function (x, y)&#123; return x + y&#125; 然後我們把 function 拿掉，參數的後面加上 =&gt;，這樣我們就完成了我們的箭頭函式。 1234const add = (x, y) =&gt; &#123; return x + y&#125;//省略 function，加上 =&gt; 如果我們的函式只有單行運算式，我們還可以省略後面的花括號 {}，然後 return 也可以省略 12const add = (x, y) =&gt; x + y// 省略 &#123;&#125; 與 return 這裡有一個重點，如果我們省略了 {}，就會有一個隱含的 return 出現在運算式前面，如果沒有省略 {}，運算式將會如實呈現。123456const add = (x, y) =&gt; x + yfunction add(x, y)&#123; return x + y&#125;//沒加 &#123;&#125; 等於 return x + y 123456const add = (x, y) =&gt; &#123;x + y&#125;function add(x, y)&#123; x + y&#125;//有加 &#123;&#125;，裡面的程式碼如實呈現，所以沒有 retrun 如果你只有一個參數，你甚至可以省略參數的圓括號1234const add = (x) =&gt; x + 5const add = x =&gt; x + 5//省略圓括號 關於參數的圓括號 如果只有一個參數，圓括號可省略 如果沒有參數，或是有兩個以上的參數，圓括號一定要加 12345678const sayHi = () =&gt; 'Hello, World!'//沒有參數，要加()const add = (n1, n2) =&gt; n1 + n2//兩個以上參數，要加()const add = n1, n2 =&gt; n1 + n2//報錯 如果 return 的是一個 object，花括號 {} 外面要加圓括號 ()1const family = (father, mother) =&gt; (&#123;father: father, mother: mother&#125;) 綁定 this傳統函式的 this 是動態的，會依呼叫的方法而決定 this。箭頭函式的 this 是看何時定義。12345678910var ooo = &#123; aaa: function()&#123; console.log(this) &#125;, bbb: () =&gt; &#123; console.log(this) &#125;&#125;;ooo.aaa() // &#123;aaa:f, bbb: f&#125;ooo.bbb() // window 參考連結:React 16 - The Complete GuideMDN - 箭頭函式ES6篇 - 箭頭函式ECMAScript 6 入门鐵人賽：箭頭函式 (Arrow functions)Arrow Functions in JavaScriptES6 箭頭函數 Arrow Function深入探討 TypeScript 之 Arrow Function","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"arrow function","slug":"arrow-function","permalink":"http://georgekuo.github.io/tags/arrow-function/"},{"name":"this","slug":"this","permalink":"http://georgekuo.github.io/tags/this/"}]},{"title":"模組(Modules)","slug":"module","date":"2018-08-13T06:13:31.000Z","updated":"2018-09-02T09:09:26.181Z","comments":true,"path":"2018/8/13/module/","link":"","permalink":"http://georgekuo.github.io/2018/8/13/module/","excerpt":"","text":"Modules 模組系統是 ES6 的新功能，透過 import 與 export 關鍵字，你可將以往冗長且結構複雜的程式碼拆解成各個小區塊，以便我們可以把A檔案的程式碼導入到B檔案使用。Exports 有兩種輸出方式，分別是 Default export 與 Named exports 預設匯出(Default export)Default export 的作用是為模組指定預設輸出。舉個例子，假設我們在 human.js 的檔案裡頭，有一個名為 person 的常數，我們用 export 將其輸出，語法為 export default person12345//human.jsconst person = &#123; name: 'Max'&#125;export default person接下來我們想要在其他的 js 檔案，例如 app.js 引入 person 這個常數，只要用 import person from ‘./human.js’ 即可，person 可換成任意名稱，因為我們已經在 human.js 指定了常數 person 為預設輸出(export default)，所以我們不管在任何地方，從 human.js 引入的預設值都是常數 person。 12345//app.jsimport person from './human.js'import prs from './human.js'import xyz from './human.js'//import 後面不管任何名稱，都是引入 human.js 的常數 person 簡而言之，這裡記住兩個重點： 每一支 JS 檔案只能有一個預設匯出(不然就不叫預設值了) export 引入的預設匯出，可以任意命名 具名匯出(Named exports)當你的 JS 有兩個以上的變數要匯出時，這時就要用具名匯出(Named exports)，以下是程式碼： 12345678//utility.jsexport const clean = () =&gt; &#123;...&#125; export const baseData = 10;export function foo()&#123; //...&#125;const Avengers = ['Ironman', 'Hulk', 'Thor', 'Loki']export &#123; Avengers &#125; 這是另一種匯出的方式，一般比較推薦此種寫法，因為這樣在 js 最下方輸出，可一眼看出總共輸出了哪些變數。12345678const clean = () =&gt; &#123;...&#125; const baseData = 10;function foo()&#123; //...&#125;const Avengers = ['Ironman', 'Hulk', 'Thor', 'Loki']export &#123; clean, baseData, foo, Avengers &#125; 匯出別名一般情況下，export 輸出的變數就是本來的名字，但你也可以使用 as 關鍵字重新命名。我們也可重複重新命名這個動作。12345678function kick_01() &#123; ... &#125;function kick_02() &#123; ... &#125;export &#123; kick_01 as k1, kick_02 as k2, kick_02 as kickkkkkkk //重複重新命名&#125;; 引入具名匯出須加大括號引入具名匯出必須明確指出引入的是哪一個變數，所以名稱必須跟匯出的名稱相同，然後在名稱前後加上花括號 {…}123//app.jsimport &#123; baseData &#125; from './utility.js'import &#123; clean &#125; from './utility.js' 匯入別名跟匯出別名一樣，你也可以在引入具名匯出後，任意的命名自己想要的名稱，只要使用 as 關鍵字即可 123import &#123; ironman &#125; from './utility.js'import &#123; tony as ironman &#125;from './utility.js'//指定一個別名，然後你可以在要導入的文件中自由選擇該別名as關鍵字 同時引入多個輸出當檔案中有多個命名輸出，你可使用 * 導入所有內容，然後分配別名並進行綁定，在此情況中，它將是一個 object，以便你可使用例如：bundled.baseData, bundled.clean …等方法，即可使用 export 的變數。1import * as bundled from './utility.js' export 與 import 一定要放在頂層範疇export 與 import 一定得出現在頂層範疇(top-level scope)。舉例來說，你不能將 export 或 import 放在 if 條件式內，它們必須出現在所有區塊與函式之外。 參考連結:React 16 - The Complete GuideECMAScript 6 入门從ES6開始的JavaScript學習生活MDN - exportES6：export default 和 export 区别你所不知道的JS：ES6與未來發展深入浅出ES6（十六）：模块 Modules","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"module","slug":"module","permalink":"http://georgekuo.github.io/tags/module/"},{"name":"export","slug":"export","permalink":"http://georgekuo.github.io/tags/export/"},{"name":"import","slug":"import","permalink":"http://georgekuo.github.io/tags/import/"}]},{"title":"解構賦值(Destructuring Assignment)","slug":"Destructuring","date":"2018-08-13T02:07:46.000Z","updated":"2018-09-02T09:09:26.176Z","comments":true,"path":"2018/8/13/Destructuring/","link":"","permalink":"http://georgekuo.github.io/2018/8/13/Destructuring/","excerpt":"","text":"解構賦值是 ES6 的新特性，可以將陣列或物件中的資料取出成獨立變數。 陣列解構陣列解構強調順序，左右對照相對應的元素，右邊陣列的值即可對左邊陣列相對應的元素賦值。1234567var foo = ['one', 'two', 'three'];var [one, two, three] = foo;console.log(one); // \"one\"console.log(two); // \"two\"console.log(three); // \"three\"Y 陣列解構 12345678910111213var a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50](&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;);console.log(a); // 10console.log(b); // 20 物件解構陣列的解構賦值強調順序，而物件的解構賦值強調的則是屬性名稱，屬性名稱必須相互對應才能夠取得到值。 在物件解構賦值中，冒號前是用來對應物件的屬性名稱，冒號後才是真正建立的變數名稱和被賦值的對象。 1234567let &#123;aaa, bbb&#125; = &#123;aaa:4, bbb:9&#125;console.log(aaa) //4console.log(bbb) //9let &#123;name&#125; = &#123;name:'Max', age: 28&#125;console.log(name) //左側的 name 屬性有對應到右側 name 屬性，所以 console name 有值console.log(age) //左側的 age 屬性沒有對應到右側 age 屬性，所以 age is not undefined 物件的模式匹配不像陣列需要對應索引值，因此在物件的解構賦值中順序不影響結果。1234567let &#123; apple, banana &#125; = &#123; apple: \"good\", banana: \"bad\" &#125;;console.log(apple) // \"good\"console.log(banana) // \"bad\"let &#123; banana , apple &#125; = &#123; apple: \"good\", banana: \"bad\" &#125;;console.log(apple) // \"good\"(即使順序不同，參照相同的索引值，還是不影響結果)console.log(banana) // \"bad\" 如果變數與屬性名都沒有對應的名稱則變數的值會是 undefined12let &#123; orange &#125; = &#123; apple: \"good\", banana: \"bad\" &#125;;console.log(orange); // undefined 也可以屬性值來當作變數對應等號後方的屬性值，寫法會是類似這樣:12345678let &#123; apple: \"feel\" &#125; = &#123; apple: \"good\", banana: \"bad\" &#125;; // 這樣會出錯，前面的引號必須拿掉let &#123; apple: feel &#125; = &#123; apple: \"good\", banana: \"bad\" &#125; //不用加引號console.log(feel); // \"good\" console.log(apple); //報錯console.log(apple) 會報錯，因為物件(object)的解構賦值的內部機制，是先找到同名屬性，然後再賦給對應的變量。真正被賦值的是後者，而不是前者，在上例中，apple 是匹配的模式，feel 才是變量。真正被賦值的是變量 feel。 12345678var &#123;a:aa = 10, b:bb = 5&#125; = &#123;a: 3&#125;;console.log(aa) // 3console.log(a) //a is not definedlet obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;console.log(f); // 'hello'console.log(l); // 'world' 不完全解構即等號左邊的模式，只匹配一部分的等號右邊的數組。這種情況下，解構依然可以成功。下面兩個例子，都屬於不完全解構，但是可以成功。123let [x, y] = [1, 2, 3];x // 1y // 2 1234let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 12345var [a,b,c] = [d,e,f]// 報錯，d, e, f is not definedvar [x,y,z] = [function()&#123;return 3&#125;, &#123;i:'ii',o:'oo'&#125;, [9,9,9]] // ok 如果等號的右邊不是陣列，解構將不被接受。12345678910111213141516// 報錯let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;;以下部分也會報錯&#123;u,i,o&#125; = &#123;\"\",\"\",\"\"&#125;&#123;u,i,o&#125; = &#123; , , &#125;但以下可以[u, i, o] = [][u, i, o] = [ , , ][u, i, o] = [ '', '', ''] 解構賦值允許指定默認值。1234let [foo = true] = [];console.log(foo) // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"destructuring","slug":"destructuring","permalink":"http://georgekuo.github.io/tags/destructuring/"}]},{"title":"let 和 const","slug":"let-and-const","date":"2018-08-08T04:22:20.000Z","updated":"2018-09-02T09:09:26.180Z","comments":true,"path":"2018/8/8/let-and-const/","link":"","permalink":"http://georgekuo.github.io/2018/8/8/let-and-const/","excerpt":"","text":"範疇在 ES6 之前，在 Javascript 要宣告變數必須要用 var。1var a = 100以 var 宣告的變數，作用範疇以 function(函式) 為基準，如果在 funciton 以外宣告，叫做全域變數，在檔案的各個位置都能使用。 在 function 以內宣告，叫做區域變數，它的作用範疇只存在於其宣告的 function 之內，離開該 function，此變數將不能再被使用。123456var a = 1 //宣告全域變數afunction ()&#123; var a = 2 //宣告區域變數a console.log(a) //2&#125;console.log(a) // 1 簡單的了解 var 之後，開始來介紹ES6 新增的變數宣告方式：let 跟 const，相對於 var 是函式作用域(function scope)，let 與 const 是區塊作用域(block scope)，這表示我們只需要一對｛⋯⋯｝就能建立一個範疇。123456let a = 10&#123; let a = 20 console.log(a) // 20&#125;console.log(a) // 10上例中第一個 console.log(a) 只接受 ｛⋯⋯｝區塊裡所宣告的變數a，所以 console.log 的結果是 20，換句話說，let a = 20 的結果只存在於｛⋯⋯｝的區塊之中，而離開了｛⋯⋯｝之後，再一次 console.log(a) 只會找到第一行的 let a = 10。 const 宣告即需給值const 定義常數，常數在一宣告時就必定要指定給值，換言之，想要先宣告後才指定值，就要用 let。 12const a = 10 // ok const a // wrong 禁止重複宣告let 與 const 禁止 在同一範疇中 再次宣告 相同名稱的變數，這點與 var 大相徑庭，var 無視重複宣告，只管指派變數值，但重複宣告的 let 與 const 會被視為語法錯誤。1234567&#123;let a = 1let a = 2 //回報錯誤，因為 a 已宣告過。let b = 20b = 35 //ok, let 雖不可重複宣告，但可接受重複指派新值&#125;1234&#123;const i = 5const i = 10 //回報錯誤，const 是常數，不能重複宣告。&#125; 禁止在宣告之前就使用它var 宣告的變數在未宣告使用，會產生 Hosting 變數提升，然而 let 與 const 並不會產生 Hosting，所以養成良好的習慣，把宣告變數盡量寫在最上方比較不容易出錯。123456&#123; console.log(a) //undefined console.log(b) //ReferenceError! var a = 1 let b = 2&#125; let 與 const 都是區域變數在函式以外的範圍用 var 宣告變數是全域變數 ，然而 let 與 const 並沒有全域變數的概念，他們永遠都是區域變數。12const ironman = 'Tony Stark'console.log(window.ironman) // undefined 暫時死亡區(TDZ, Temporal Dead Zone)在區塊範疇中，過早存取由 let, const 宣告的變數，由於 let , const 並無 Hosting，所以會造成存取已宣告但未初始化的變數，進而造成錯誤 ReferenceError。12345678910console.log(q) // q 為 undefined, 因為 hoistingvar q = 5;&#123; console.log(x) console.log(y) let x = 3; const y = 5; // let 跟 const 沒有 hoisting，所以會進入暫時性死區&#125; 參考連結:React 16 - The Complete GuideECMAScript 6 入门React - DOM界的彼方(繁中)前端，沒有極限 - 鐵人賽：ES6 開始的新生活 let, const","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://georgekuo.github.io/tags/es6/"},{"name":"let","slug":"let","permalink":"http://georgekuo.github.io/tags/let/"},{"name":"const","slug":"const","permalink":"http://georgekuo.github.io/tags/const/"}]},{"title":"react 簡單入門","slug":"react-introduce","date":"2018-08-06T07:41:22.000Z","updated":"2018-09-02T09:09:26.183Z","comments":true,"path":"2018/8/6/react-introduce/","link":"","permalink":"http://georgekuo.github.io/2018/8/6/react-introduce/","excerpt":"","text":"本系列是我學習 React 的心得筆記，主要參考 Udemy 上的 React 線上課程 React 16 - The Complete Guide，並輔以 React官方文件、css88 React中文文件，如有說錯或說不好之處，請各位不吝指教。 什麼是 React?JavaScript library for building user interfaces。 React 官網開宗明義的第一句話告訴我們，React 是一套用於建構使用者介面的 JavaScript 函式庫。 由於 React 就是 JavaScript，所以 React 直接在瀏覽器運作，這表示頁面任何的變化會在用戶的瀏覽器即刻產生，不需等伺服器回應，大大提升反應速度。React 使用元件 (以下以 Components 稱呼之) 建構使用者介面，一個網頁的基本架構可拆成數個 Components，我們以一般最普遍的網頁解釋，React 將 header, sidebar, article, footer…等網頁元素都製成 Components，這讓我們在建構網站時，可將相同的 Components 重複利用而不必撰寫重複的程式碼，這讓團隊協作變得更加容易，當網站需要修改時，也只需要從 Components 修改，而不必將整個網站翻來覆去只為了修改一個小地方。 你可以將 React Components 視為你的自定義 HTML 元素，撰寫 React 視為撰寫你的自定義 HTML 元素，透過 React，你可撰寫易於維護、方便管理，以及可重複使用的程式碼。 Hello, world! Hello, React!接下來讓我們開始撰寫第一支 React 程式碼，你可以打開你習慣的文字編輯器 (VSCode, Sublime, Atom…etc)，或是使用 Codepen，CodeSandbox 等線上工具，在這裡我們用 Codepen 完成這個範例。 首先我們先在 HTML 裡輸入以下程式碼：1234&lt;div class=\"person\"&gt; &lt;h2&gt;Westbrook&lt;/h2&gt; &lt;p&gt;Age: 30&lt;/p&gt;&lt;/div&gt; 接著撰寫 CSS：1234567.person &#123; padding: 0 20px; margin: 10px; border: 1px solid gray; box-shadow: 2px 2px gray; display: inline-block;&#125;你會看到我們已經手刻出一張帶有名字與年齡的小卡。 See the Pen React demo by phate (@phate) on CodePen. 此時如果我們想要在網頁中增加第二張小卡，最直接的方式就是在 HTML 裡複製貼上整段 &lt;div class =”person”&gt;123456789&lt;div class=\"person\"&gt; &lt;h2&gt;Westbrook&lt;/h2&gt; &lt;p&gt;Age: 30&lt;/p&gt;&lt;/div&gt;&lt;div class=\"person\"&gt; &lt;h2&gt;George&lt;/h2&gt; &lt;p&gt;Age: 28&lt;/p&gt;&lt;/div&gt;在2018年，讓我們用 React 來解決這問題。 首先，在 Codepen 的 JS 欄左上方找到一個齒輪，用力的點下去。 接著會出現 Codepen 的 JavaScript 設定視窗，在 JavaScript Preprocessor 選擇 Babel，然後在 Add External Scripts/Pens 處，我們在搜尋框打上 react，載入 react.js 與 react-dom.js，接著你就可以在 JS 欄寫 React 了。 讓我們開始撰寫 React Component，以便讓我們有一個可重複使用的自定義 HTML 元件，我們先把第一個小卡的 HTML 複製剪下，改成 &lt;div id=”p1”&gt; &lt;/div&gt;123456&lt;div id=\"p1\"&gt;&lt;/div&gt;&lt;div class=\"person\"&gt; &lt;h2&gt;Payton&lt;/h2&gt; &lt;p&gt;Age: 28&lt;/p&gt;&lt;/div&gt; 緊接著，我們在 JS 裡命名一個 Person 的 function，注意函數名稱的第一個字母要大寫，然後把剛剛 HTML 剪下的 &lt;div class =”person”&gt; 貼在 function 的 return 裡，並用小括號包起來，這是 JSX 的語法，JSX 以後會提到，這邊只要先知道 JSX 是一種可以讓HTML標記直接寫在JavaScript程式碼中的擴充語法即可。而因為 class 是 JavaScript 的關鍵字，所以在 JSX 裡，記得把 class 改成 className。12345678function Person()&#123; return( &lt;div className=\"person\"&gt; &lt;h2&gt;Westbrook&lt;/h2&gt; &lt;p&gt;Age: 30&lt;/p&gt; &lt;/div&gt; )&#125; 接著我們要在頁面中渲染出我們的 React Component，記得我們在 JS 設定裡有載入一支 React-dom.js 嗎？我們要使用它的 ReactDOM.render() 方法，這讓我們可以將 JavaScript 函數呈現為真實的 DOM，在 ReactDOM.render() 裡頭，第一個參數寫上我們的自定義 HTML 函數 &lt;Person /&gt;，然後第二個參數撰寫 document.querySelector(‘#p1’)，這會讓我們的 Copmonent 渲染在#p1。 1234ReactDOM.render( &lt;Person /&gt;, document.querySelector('#p1')) 因為我們是在 #p1 塞入 function Person() 的 JSX ，#p1 預設是 display:block，為了併排，我們另外在 CSS 設定 #p1 的 display 值為 inline-block。123#p1 &#123; display: inline-block;&#125; 接著就可以驗收我們的成果：我們成功的自訂 React Component(function Person) 並且渲染在 #p1。 See the Pen react introduce - 02 by phate (@phate) on CodePen. 剛剛 HTML 的程式碼幾乎原封不動的貼到 JSX 裡，雖然簡化了 HTML，但是對於 JS 來說並沒有簡化到哪去，所以我們現在要把 JSX 裡會變化的參數抽出來，這裡用到 React 一個傳遞參數的功能 props。 現在我們把 function Person() 放入參數 props，然後把 JSX 的姓名與年齡抽出來，用{props.name} 與 {props.age} 代替。12345678function Person(props)&#123; return( &lt;div className=\"person\"&gt; &lt;h2&gt;&#123;props.name&#125;&lt;/h2&gt; &lt;p&gt;Age: &#123;props.age&#125;&lt;/p&gt; &lt;/div&gt; )&#125; 接著我們將個別的姓名與年齡寫在 ReactDOM.render 的根物件 裡：12345678ReactDOM.render( &lt;Person name='Gary' age='30' /&gt;, document.querySelector('#p1'))ReactDOM.render( &lt;Person name='Payton' age='28' /&gt;, document.querySelector('#p2')) 現在再來看一下我們的成果： See the Pen react introduce - 03 by phate (@phate) on CodePen. 最後，為了避免連續調用兩次 ReactDOM.render，我們宣告一個變數 app 把兩組 &lt;Person &sol;&gt; 放進去，這裡有一個重點，JSX 只接受一個根元素，所以我們必須另外用 div 把兩組 &lt;Person &sol;&gt; 包起來。 以下程式碼就是我們的最終成果。 See the Pen react introduce - 04 by phate (@phate) on CodePen. 參考連結:React 16 - The Complete Guide搞懂為何設定 React、JSX、ES2015、Babel、Webpack 的學習筆記RUNOOB.COM - React 安装DOM界的彼方(繁中) - React篇: JSX語法撰寫指引React 初学者教程7：深入 JSX","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://georgekuo.github.io/tags/react/"}]}]}